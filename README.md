“猜密码”软件
  这里要制作的是一款提供“猜密码”功能的软件。人在设置密码时可能会下意识地从周遭事物中汲取灵感，基于这样的想法，本软件旨在收集目标的姓名、年龄、生日、爱好、地址等等信息，然后利用这些信息生成一个可能密码字典，帮助在特定场合提高密码破译效率。开发环境是Qt Creator 4.0.3(Communit) 、语言是c++，使用Qt Creator附带的Sqlite数据库。
设计：
  在设计过程中，我把程序编写主要划分为三个部分：1.编写一个供用户操作的图形页面，用于填写信息、修改信息。2.在数据库中保存用户填写的信息（供后期用户查看和修改），并将生成的密码字典也保存在数据库中。3.密码字典生成算法。
  
信息采集。以每个人为单位，设计有十七类信息共二十七项可以采集，这十七类信息里有纯数字的比如手机号身份证号，有纯字母的比如爱人子女父母的名字工作单位名，也有数字和字母混杂的比如社交软件上的昵称旧密码；由字母串组成的信息里也有汉语拼音（即带空格）和纯英文（即不带空格）的区别。

  涉及字符串组的处理略显繁琐，但本质上还是分组处理的问题。容易出现字符串的信息比如名字、家庭地址、爱好、家属及朋友.......分为两组，一组是姓名组，一组是非姓名组（该组又分为两类，一组为含有空格，另一组不含空格）。姓名组的处理是这样的：1.首字母缩写串，比如说peng sheng jie 我们得到 psj/PSJ/P/p/（复姓）取前两个首字母2姓 ，PENG/peng/Peng/（复姓）peng sheng Peng Sheng PENG SHENG 3 姓+姓pengPENG/PENGpeng。非姓名组，如果含有空格，则提取首字母做全大写和全小写（HDU/hdu），如果不含空格，则将整体全大写全小写。

处理数字串组简单些，采用的主要是截取和拼凑日期、电话号码、qq号等操作。代码简短且有较详细注释。

从旧密码以及微信号等中提取字符串、数字串和特殊符号的操作，利用的是正则表达式。

信息的处理是一个“收集——拆解——组合”的过程，尽管收集的信息看上去名目不少，经过拆解后它实际上是并入三个大类：字符串组、数字串组和特殊符号组，为了提高效率尽量与暴力破解区分，在筛选时应选择长度大于等于2的串。

经过去重判断等预先处理操作，可以将上述信息混合了。

密码字典生成算法是全软件的重点，涉及“Passwordgenerate.h”文件和“w1.cpp”、“w2.cpp”里的genenrate_password()函数。

接下来介绍图形界面和连接数据库部分。

模块一：图形界面。
图形界面共由一个欢迎页面、一个新建页面和一个修改页面构成。文件w1对应新建页面，w2对应修改页面。修改页面与新建页面内容绝大部分是相同的，区别在于修改页面的姓名栏是下拉框选择模式，并且选择名字的不同，下面也会显示相应的信息。另外图形界面的好处比命令行好太多了，输入会更加规范，想修改前面几项的内容也很方便，如下：
欢迎页面
![image text](https://github.com/17061603/guessThem/blob/master/img-folder/%E5%9B%BE%E7%89%871.png)
新建页面
![image text](https://github.com/17061603/guessThem/blob/master/img-folder/%E5%9B%BE%E7%89%872.png)
修改页面
![image text](https://github.com/17061603/guessThem/blob/master/img-folder/%E5%9B%BE%E7%89%873.png)

模块二：对数据库的操作涉及四个函数：
void w1::connectDB() //连接数据库
void w1::on_thename_currentIndexChanged(const QString &arg1)//名字查询，显示用户信息
void w1::on_pushButton_released()//改写用户信息并存储于数据库
void w1::write_DB(QString numid)//将生成的密码字典写入数据库
在这里当产生修改用户信息动作时，不仅是修改用户本身的信息，还要将用户已经产生的密码字典覆盖。

Sqlite里使用1+N张表的形式，一张表存储每个用户的姓名、出生年月日、家庭地址、电话号码等等，每个用户拥有一个独一无二的编码（键值）。而每个用户都分配一张存储密码字典的表，表明格式为“xx”+编码。
![image text](https://github.com/17061603/guessThem/blob/master/img-folder/%E5%9B%BE%E7%89%874.png)
此外，该软件额外提供一张表“pre”，里面含有中国人常用密码15024条，供用户选择“是否加入本软件提供的密码库”时使用。
![image text](https://github.com/17061603/guessThem/blob/master/img-folder/%E5%9B%BE%E7%89%875.png)

发展：
本软件设计粗糙，细看可发展的地方其实很多。在项目目录地方其实一直没有介绍到的四个文件“UIChinaCity.cpp”、“UIChinaCity.h”、“chineseletterhelper.cpp”、“chineseletterhelper.h”,前两个是关于我国省市区县的查询，后两者是提供汉字转拼音的功能。为了切割字符串更方便和方便填写，我曾经有过汉字化的想法，但考虑到1.目前密码少有支持汉字2.汉字和字母混杂会给后台识别时添加负担，最终放弃采用这四个文件。但我发现现在一些解压软件已经支持繁体中文密码。

其次是排序的问题。有这样的猜想：旧密码中的字符串被重复使用的可能性更高。为了更快地破解密码，可将可能性高的密码放在字典靠前的位置。我写了一个设置权重的函数，后来忙别的忘了orz。

本软件密码字典的形成途径，很多只出自于我和我周遭朋友平时设密码的经验习惯，还有csdn某次那啥后分析出来的信息，充其量只是做出一个模板，要使更加科学有效，恐怕还是要借助统计学。经验之谈，整个制作过程中我的感受是：一是密码字典的数目不宜太多，太多与暴力破解的效率接近，就没什么意思了。但由于缺乏实际应用方面的信息，多少是多也很难说，折中的方法就是尽可能生成多的密码，然后把可能性大的密码放在前面。二是密码破译器的现实应用。其实能允许人上万次输入的密码设备应该是很少的，错误达到一定次数，负责任的设备应自动发出警报或拒绝输入；其次，网络上有很多密码自动生成和保管软件，在稍微重要的场合，除了虹膜、指纹验证外，哪怕是要手工输入密码，其密码也不大可能是来自生日地址的脑筋急转弯。所以我的重心一直放在genenrate_password()函数上，网上有人提到的——适应不同场合、网站和应用的密码破译，我没有考虑。


收获：
程序调试和源码一样重要。曾经碰到过一个问题，程序报错“terminate called after throwing an instance of 'std::bad_alloc'what(): std:: bad_alloc”，最开始判断是vector导致内存不够，于是给整个项目替换了数据类型，由于数据类型换了相应函数也更换了，折腾了两周还是没有解决，最后某日突然发现每次都停在同一个函数上，原来是正则表达式“[^0-9a-zA-Z]”多了一个“*”变成了死循环。再如将密码字典写入数据库速度过于缓慢，本来还想使用多线程提速，因为在写“pre”表时重开了一个项目，发现百万级别的数据竟然只需几十秒，十分纳闷。最后才发现是本项目在连接数据库时发生了内存泄漏，又修改了连接函数。最后是笔记的重要性，即使不做笔记，在浏览器里多建几个收藏夹，节省了重复劳动。
